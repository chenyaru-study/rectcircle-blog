---
title: 机器学习笔记（一）——斯坦福大学吴恩达（Andrew Ng）课程
date: 2017-04-14T19:29:50+08:00
draft: false
toc: false
comments: true
aliases:
  - /detail/64
  - /detail/64/
tags:
  - 机器学习
---

<script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=default"></script>

## 目录
* [一、介绍](#一、介绍)
	* [1、什么是机器学习](#1、什么是机器学习)
	* [2、监督学习](#2、监督学习)
	* [3、无监督学习](#3、无监督学习)
	* [4、模型和代价函数](#4、模型和代价函数)
		* [（1）线性回归算法](#（1）线性回归算法)
		* [（2）代价函数](#（2）代价函数)
	* [5、参数学习](#5、参数学习)
		* [（1）梯度下降算法](#（1）梯度下降算法)
* [二、多特征线性回归](#二、多特征线性回归)
	* [1、多变量相关定义](#1、多变量相关定义)
	* [2、多变量梯度下降法](#2、多变量梯度下降法)
	* [3、梯度下降法实用技巧](#3、梯度下降法实用技巧)
		* [（1）特征缩放法](#（1）特征缩放法)
		* [（2）学习率](#（2）学习率)
	* [4、多特征和多项式回归](#4、多特征和多项式回归)
	* [5、正规方程Normal Equation求解线性回归](#5、正规方程Normal Equation求解线性回归)
* [三、Octave语言](#三、Octave语言)
	* [1、基本命令](#1、基本命令)
	* [2、移动数据](#2、移动数据)
	* [3、数据计算](#3、数据计算)
	* [4、绘制数据和数据可视化](#4、绘制数据和数据可视化)
	* [5、流程控制和函数](#5、流程控制和函数)
	* [6、向量化](#6、向量化)
* [四、分类问题](#四、分类问题)
	* [1、分类问题简介](#1、分类问题简介)
	* [2、逻辑回归模型](#2、逻辑回归模型)
	* [3、决策边界](#3、决策边界)
	* [4、逻辑回归的代价函数](#4、逻辑回归的代价函数)
	* [5、实现逻辑回归的梯度下降算法](#5、实现逻辑回归的梯度下降算法)
	* [6、高级优化](#6、高级优化)
	* [7、多分类问题](#7、多分类问题)
* [五、过度拟合的问题](#五、过度拟合的问题)
	* [1、拟合的一些概念](#1、拟合的一些概念)
	* [2、过渡拟合解决方法](#2、过渡拟合解决方法)
	* [3、正规化与代价函数](#3、正规化与代价函数)
	* [4、正规化线性回归](#4、正规化线性回归)
	* [5、正规化逻辑回归](#5、正规化逻辑回归)





## 一、介绍
******************************
### 1、什么是机器学习
#### （1）Samuel定义
> 在进行特定编程的情况下， 给予计算机学习能力的领域。

#### （2）Tom Mitchell定义
 > 一个程序被认为能从经验E中学习，解决任务 T，达到 性能度量值P，当且仅当，有了经验E后，经过P评判， 程序在处理 T 时的性能有所提升。

问题：
在这种Email程序中，你点击“垃圾邮件”按钮 报告某些email为垃圾邮件，不会影响别的邮件。基于被标记为垃圾的邮件， 您的电子邮件程序能更好地学习如何过滤垃圾邮件。请问， 在这个设定中，任务 T 是什么？

T：对电子邮件是否是垃圾邮件进行分类
E：观测用户对于垃圾邮件的标记
P：电子邮件被准确区分的概率

#### （3）机器学习的分类
* 监督学习
* 无监督学习



### 2、监督学习
>  在监督学习中，我们给出了一个数据集，并已经知道了我们的正确的输出应该是什么样子，有想法，有输入和输出之间的关系。

监督学习问题被归类为“回归”和“分类”问题。在回归问题，我们试图连续输出中预测的结果，这意味着我们正在尝试输入变量映射到一些连续函数。在分类问题，我们不是试图预测离散输出结果。换句话说，我们正试图输入变量映射到不同的类别。

#### （1）回归问题
示例：
关于房价和面积的，给定数据集是面积和价格的映射，让你给出卖方的建议

通过离散值预测连续值


#### （2）分类问题
实例：
给定数据集：病人身体的特征，和该病人肿瘤的类型。让你预测病人肿瘤的类型

给定特征值判进行分类

#### （3）课堂问题
第一个问题，你有一堆货物的清单。 假设一些货物有几千件可卖， 你想预测出，你能在未来三个月卖出多少货物。 第二个问题，你有很多用户， 你打算写程序来检查每个用户的帐目。 对每个用户的帐目， 判断这个帐目是否被黑过（hacked or compromised）
答案：
问题一是个回归问题 因为如果我有几千件货物， 可能只好把它当作一个实际的值，一个连续的值。 也把卖出的数量当作连续值。 第二个问题，则是分类问题，因为可以把 我想预测的一个值设为0，来表示账目没有被hacked 另一个设为1，表示已经被hacked。


### 3、无监督学习
无监督的学习可以让我们接近，我们不知道结果应该是什么样子的问题。

我们可以通过聚类算法，根据数据之间的关系来分类。

**例子：**
集群：以100万个不同的基因集合，并找到一种方法来自动组这些基因成在某种程度上相似或不同的变量，如寿命，位置，角色等相关的组。

非群集：“鸡尾酒会算法”，可以让你找到结构混乱的环境。（即在确定个人的声音和音乐声音的的录音中分离出人声和音乐声）。


### 4、模型和代价函数
#### （1）线性回归算法
**符号定义**
m =  训练样本的数目
x = 输入变量或特征
y = 输出变量或目标变量
(x,y) = 一个训练样本
(x(i), y(i)) = 第i个训练样本

**监督学习运行方式**
训练过程： 训练集 -> 学习算法 -> h（一个假设函数hypothesis）
运行过程： x -> h -> y
h的表示方式：


**h函数：`hθ(x)=θ0+θ1*x `**称之为
单变量线性回归

#### （2）代价函数
**问题**
给定数据数目为m的数据集`{(xi,yi)|i∈[1,m]}`。请使用线性方程拟合出最优的θ0和θ1
**将问题转化为代价函数**
已知假设函数：`hθ(x)=θ0+θ1*x`
请求出θ0和θ1的一个解，使得 `J(θ0,θ1) = (1/(2*m))*∑(i=1,m)(hθ(xi)-yi)2`的值最小
其中函数`J(θ0,θ1)`就是本问题的一个**代价函数（costfunction）**或平方误差代价函数

格式化函数如下（类似于方差）
$$J(\theta\_0, \theta\_1)=\frac{1}{2m}\sum\_{i=1}^m (h\_\theta(x^{(i)})-y^{(i)})^2$$

我们可以使用代价函数来衡量我们的假设函数的准确性

![](/res/-0LPwi4bBlLrVr3VvWaEaTHZ.png)

**对于线性回归问题的术语**
Hypothesis（假设函数）
\\(h\_\theta=\theta\_0 + \theta\_1\\)

Parameters（参数）
\\(\theta\_0\\)和\\(\theta\_1\\)

Cost Function（代价函数）
\\(J(\theta\_0, \theta\_1)=\frac{1}{2m}\sum\_{i=1}^m (h\_\theta(x^{(i)})-y^{(i)})^2\\)


Goal（目标）：使得\\(J(\theta\_0, \theta\_1)\\)最小的参数带入假设函数得到的函数称为目标函数


### [5、参数学习](#5、参数学习)
####  [（1）梯度下降算法](#（1）梯度下降算法)
重复直到收敛{
\\(\theta\_j := \theta\_j - 	\alpha\frac{\partial}{\partial\theta\_j}J(\theta\_0, \theta\_1)\\)
for(i=0,1)
}

当具体应用于线性回归的情况时，对梯度下降方程进行化简（利用微积分偏导数相关知识）易得：
重复直到收敛{
\\(\theta\_0 := \theta\_0 - \alpha\frac{1}{m}\sum\_{i=1}^m(h\_\theta(x\_i)-y\_i)\\)
\\(\theta\_1 := \theta\_1 - \alpha\frac{1}{m}\sum\_{i=1}^m((h\_\theta(x\_i)-y\_i)x\_i)\\)
}


其中
\\(\alpha\\)称之为学习率，最好动态的根据偏导数值得变化而变化，过大，可能到时发散，过小学习效率过低。

## 二、多特征线性回归
************************************************************

例子：预测房价

|尺寸（feet^2）|卧室数量|层数|房龄|价格（$1000）|
|-------------|-------|----|----|----|
|2104|5|1|45|460|
|1416|3|2|40|232|
|1534|3|2|30|315|
|852|2|1|36|178|
|...|...|...|...|...|
|x1|x2|x3|x4|y|

### 1、多变量相关定义
#### （1）符号定义
* n = 特征的数量
* m = 训练样本的大小
* \\(x^{(i)}\\) = 第i个训练样例（是一个向量）
* \\(x\_j^{(i)}\\) = 第i个训练样例的第j个特征的值（是一个标量）

如上例中



#### （2）假设函数
**原始写法**
$$
h\_\theta(x)=\theta\_0 + \theta\_{1}x\_1 + \theta\_{2}x\_2 + \theta\_{3}x\_3 + \cdots + \theta\_{n}x\_n
$$

**进一步变形**
定义\\(x\_0^{(i)}\\)=1，则
$$
h\_\theta(x)=\theta\_0x\_1 + \theta\_{1}x\_1 + \theta\_{2}x\_2 + \theta\_{3}x\_3 + \cdots + \theta\_{n}x\_n 
$$


**矩阵写法**
定义
$$
X=\begin{bmatrix}
x\_0 \\\\
x\_1 \\\\
x\_2 \\\\
\vdots \\\\
x\_n \\\\
\end{bmatrix}
$$

$$
\theta=\begin{bmatrix}
\theta\_0 \\\\
\theta\_1 \\\\
\theta\_2 \\\\
\vdots \\\\
\theta\_n \\\\
\end{bmatrix}
$$

$$
\theta^T=\begin{bmatrix}
\theta\_0 & \theta\_1 & \theta\_2 & \cdots & \theta\_n 
\end{bmatrix}
$$

则
$$
h\_\theta(x)=\begin{bmatrix}
\theta\_0 & \theta\_1 & \theta\_2 & \cdots & \theta\_n 
\end{bmatrix}
\begin{bmatrix}
x\_0 \\\\
x\_1 \\\\
x\_2 \\\\
\vdots \\\\
x\_n \\\\
\end{bmatrix}
$$

则
$$
h\_\theta(x)=\theta^TX 
$$


### 2、多变量梯度下降法
**假设函数**
\\(h\_\theta(x)=\theta^TX =\theta\_0x\_0 + \theta\_{1}x\_1 + \theta\_{2}x\_2 + \theta\_{3}x\_3 + \cdots + \theta\_{n}x\_n \\)

**参数**
\\(\theta\_0,\theta\_1,\theta\_2 \cdots \theta\_n\\)
即向量
\\(\theta\\)

**代价函数**
$$
J(\theta) = J(\theta\_0,\theta\_1,\theta\_2 \cdots \theta\_n) = 
\frac{1}{2m}\sum\_{i=1}^m (h\_\theta(x^{(i)})-y^{(i)})^2
$$

**梯度下降算法**
重复直到收敛{
\\(\theta\_j := \theta\_j - 	\alpha\frac{\partial}{\partial\theta\_j}J(\theta\_0,\theta\_1,\theta\_2 \cdots \theta\_n) = \theta\_j - 	\alpha\frac{\partial}{\partial\theta\_j}J(\theta)\\)
(同时更新对于每一个j =0,...,n)
}

化简得

重复直到收敛{
\\(\theta\_j := \theta\_j - \alpha\frac{1}{m}\sum\_{i=1}^m((h\_\theta(x^{(i)})-y^{(i)})x\_j^{(i)})\\)
(同时更新对于每一个j =0,...,n)
}

### 3、梯度下降法实用技巧
#### （1）特征缩放法
当各个特征变量的取值范围相差很大时，使用梯度下降法，效率很低，此时可以将各个特征的值进行缩放到相似的取值范围

将各个变量缩放到`[-0.5,0.5]`的范围内
$$
x\_1 = \frac{x\_1-\mu\_1}{S\_1}
$$

其中
* \\(\mu\_1\\) 为 \\(x\_1\\)的所有取值的平均值
* \\(S\_1\\) 为 \\(x\_1\\)的取值范围的差，即最大-最小




#### （2）学习率
如何选择梯度下降算法中的学习率 \\(\alpha\\)？

* 绘制出`纵轴`为\\(J(\theta)\\)和`横轴`为梯度下降算法的迭代次数
* 图形为单调递减，表示算法正常工作，正常收敛
* 图形为单调递减，但是较为平缓表示算法正常工作，正常收敛，但是学习率\\(\alpha\\)过小
* 图形为单调递曾，表示算法发散了，学习率\\(\alpha\\)过大
* 若图形为一个波浪线，表示算法在发散与收敛间波动

**总结**
* 如果 \\(\alpha\\)太小：缓慢收敛
* 如果 \\(\alpha\\)太大：\\(J(\theta)\\)每一次都不能减少;可能不会收敛
* 去尝试\\(\alpha\\)的值为..., 0.001, 0.01, 0.1, 1,...
* 或者使用另一种算法，来更新\\(\alpha\\)的值

### 4、多特征和多项式回归
#### （1）多特征，进行预处理
例如：预测房价
\\(h\_\theta(x)=\theta\_0 + \theta\_{1}占地宽 + \theta\_{2}占地长\\)
预处理
x=占地宽\*占地长
转化为
\\(h\_\theta(x)=\theta\_0 + \theta\_{1}x\\)

#### （2）多项式回归
\\(h\_\theta(x)=\theta\_0 + \theta\_1x + \theta\_2x^2 + \theta\_3x^3\\)
预处理
* \\(x\_1=x\\)
* \\(x\_2=x^2\\)
* \\(x\_3=x^3\\)

转换为多参数线性回归
\\(h\_\theta(x)=\theta\_0 + \theta\_1x\_1 + \theta\_2x\_2 + \theta\_3x\_3\\)

然后进行[特征缩放](#（1）特征缩放法)，运用梯度下降法求解


### 5、正规方程Normal Equation求解线性回归
#### （1）说明
对于预测房价的[例子](#二、多特征线性回归)，假设`m=4`
**定义：**
$$
X=\begin{bmatrix}
1 & 2104 & 5 & 1 & 45 \\\\
1 & 1416 & 3 & 2 & 40 \\\\
1 & 1534 & 3 & 2 & 30 \\\\
1 & 852 & 2 & 1 & 36
\end{bmatrix}
$$

$$
y=\begin{bmatrix}
460 \\\\
232 \\\\
315 \\\\
178 
\end{bmatrix}
$$

则可以直接求出\\(\theta\\)的值
**公式为**
$$
\theta = (X^TX)^{-1}X^Ty
$$

Octave语法
```
pinv(X'*X)*X'*y
```

#### （2）正规方程和梯度下降法的优劣
**梯度下降法**
缺点：
* 需要选择合适的学习率\\(\alpha\\)
* 需要很多次迭代

优点：
* 当特征量数目n很大(n>10000)时，任然可以很好的运行
* 适用性强，不仅可以解决线性回归问题，还可以解决想逻辑回归的问题


**正规方程**
优点：
* 不需要选择学习率\\(\alpha\\)
* 不需要迭代

缺点：
* 当特征量数目n很大(n>10000)时，运行的很慢（复杂度O(n3)）
* 仅仅应用于线性回归问题


#### （3）正规方程XX'不可逆的情况
**原因：**
* 出现退化矩阵
* 训练样本数m过小，而特征量过大导致XX'不可逆

**解决**
* 消除一些多余的参数

## 三、Octave语言
### 1、基本命令
#### （1）基本数学运算
```
1+2
3-2
2*5
2/7
2^10
2%3
```


#### （2）逻辑运算
```
1==2 %false ，百分号是注释
1 ~= 2 %不等于
1 != 2 %不等于
1 && 0 %逻辑且
1 || 0 %逻辑或
xor(1,0) %抑或
```

### （3）设置命令提示符
```
PS1('>> ')
```

### （4）定义变量
```
a = 1 %定义变量
a = 1; %加分号，表示不会再屏幕上打印
b = 'hi'
```

### （5）打印变量
```
pi
a = pi;
a
disp(a); %直接输出到控制台
disp(sprintf('保留两位数：%.2f',a)) %似乎不支持中文

format long %配置控制台，以后的小数将输出小数位长
format short %配置控制台，以后的小数将输出小数位短
```

### （6）建立矩阵
```
a = [1 2; 3 4; 5 6] #矩阵
v = [1 2 3] %行向量
v = [1;2;3] %列向量

v = 1:1:3 %创建从1到3步长为1的行向量（步长为1可以省略）

ones(2,3) %创建2行3列的矩阵，所有元素为1
2*ones(2,3) %创建2行3列的矩阵，所有元素为2

zeros(1,3) %创建一个1行3列的全为0的矩阵

rand(1,3) %创建一个1行3列的元素为0~1随机数的矩阵

eye(4) %创建单位矩阵

w = randn(1,3) %创建1行3列的元素为按照标准正太分布的值为元素的矩阵
w = -6 + sqrt(10)*(randn(1,10000)); %实验
hist(w) %绘制直方图，6个
hist(w,50) %绘制直方图，50个
```

### （7）查看帮助
```
help eye %查看函数eye的帮助
```

### 2、移动数据
#### （1）矩阵的尺寸
```
A = [1 2; 3 4; 5 6]
size(A) %返回A的尺寸，一个1*2的矩阵[m,n]，表示m行n列，测试size(size(A))
size(A,1) %返回矩阵的行数
size(A,2) %返回矩阵的列数

length(A) %返回矩阵的最大维度，此时返回3，一般对向量执行length命令
```

#### （2）文件操作
```
pwd %打印当前路径
cd '目录' %切换目录
ls %列出目录和文件

load 文件名 %加载文件，注意文件编码文ANSI，不支持中文
load('文件名') %以函数的形式
load featuresX.dat
load priceY.dat
```

#### （3）查看删除变量
```
who %显示当先工作空间储存的变量
whos %详细显示当先工作空间储存的变量

clear x %删除变量
clear %删除所有变量
```


#### （4）变量赋值
```
v = featuresX(1:3) %将变量的前3个元素存入v中
```

#### （5）保存到本地文件
```
save hello.mat v; %将变量v保存到文件中，以二进制形式
save hello.txt v -ascii; %将变量v保存到文件中，以文本文件形式
```

#### （6）访问和更改矩阵行列和元素
```
A(3,2) %访问向量A的第3行第2列的元素
A(2,:) %访问向量A的第2行的所有元素，结果也是一个矩阵
A(:,2) %访问向量A的第2列的所有元素，结果也是一个矩阵
A([1 3],:) %访问向量A的第1和3行的所有元素
A(:,1:2) %取1、2列的所有元素
A(x:y) %求A的子矩阵，返回第x行、第y列元素的组成的矩阵

A(:,2) = [10; 11; 12] %给第二列的所有元素赋值

A = [A,[100; 101; 102]] %给矩阵A再加一列

A[:] %将矩阵A的所有组成一列
% 1 2 3
% 4 5 6
% 结果
% 1
% 4
% 3
% 5
% 3
% 6

C = [A B] %将矩阵直接连在一起，A在左边，B在右边；或者写成 [A, B]
C = [A; B] %将矩阵直接连在一起，A在上边，B在下边（;意味着换行）
```


### 3、数据计算
#### （1）矩阵乘法
```
A = [1 2; 3 4; 5 6]
B = [11 12; 13 14; 15 16]
C = [1 1; 2 2]
A*C
A^2 %矩阵的自身乘法
```

#### （2）按元素运算 `.操作符`
```
A .* B %按元素乘 %若B为标量，可以写成*

A .^ 2 %每个元素二次方，不可以简写成 ^，因为^2表示自身相乘

v = [1;2;3]

1 ./ v %v中每个元素取倒数
```
#### （3）元素单元操作
```
log(v) %对每个元素取自然对数

exp(v) %每个元素作为e的指数的值

abs(v) %对每个元素取绝对值

-v %对每一位取相反数

```

#### （4）元素双元操作
```
v + ones(length(v), 1) %等于v + [1;1;1] 等价于v + 1; v .+ 1
```

#### （5）矩阵的转置\\(A^T\\)、翻转
```
A' %转置
flipud (X) %上下翻转
fliplr (X) %左右翻转
```

#### （6）最大、最小、求和、乘积、取整
```
a = [1 15 2 0.5]
val = max(a) %对于行矩阵 求出矩阵中最大的元素的值
[val, idx] = max(a) %矩阵中最大的元素的值赋值给val，索引位置为idx

max(A) %求每一列的最大值
max(A, B) %矩阵A、B相同位置的元素相比取大的一个
max(A,[],1) %求每一列的最大值
max(A,[],2) %求每一行的最大值

sum(a) %所有元素相加得到的值
sum(A,1) %按列求和
sum(A,2) %按行求和

prod(a) %对所有元素依次相乘

floor(a) %对所有元素向下取整

ceil(a) %对所有元素向上取整
```

#### （7）元素逻辑运算
```
a < 3 %每个元素 执行逻辑元素的结果
```

#### （8）查找元素
```
find(a < 3) %返回行向量满足逻辑运算的的元素的索引
find(A < 3) %返回矩阵A的满足逻辑运算的的元素的索引，1~n*m，从左往右，从上到下
A = magic(3)
[r,c] =  find(A>=7) %r为满足条件的元素的行号，c为满足条件的元素的列号
```


#### （9）`magic`函数产生幻方
```
magic(3) %产生一个3*3的矩阵，每行的和、每列的和和对角线的和相等，元素取值为1到9
```

#### （10）求逆\\(A^{-1}\\)
```
pinv(A) %求逆，pinv(A)*A = eye(n)
```


### 4、绘制数据和数据可视化
#### （1）分别绘制图像，绘制后面的，会先取消前面绘制的
```
t = [0:0.01:0.98]; %定义横坐标
y1 = sin(2*pi*4*t); %定义纵坐标
plot(t, y1) %绘制二维图形，t为横坐标，y1为纵坐标

y2 = cos(2*pi*4*t);
plot(t, y2) %绘制二维图形，t为横坐标，y1为纵坐标
```

#### （2）在同一个图上绘制多个曲线
```
plot(t, y1) %绘制二维图形，t为横坐标，y1为纵坐标
hold on %保持图像
plot(t, y2, 'r') %绘制二维图形，t为横坐标，y1为纵坐标，颜色为红
```

#### （3）添加标注
```
xlabel('time') %x轴的标签
ylabel('value') %y轴的标签
legend('sin', 'cos') %给两个曲线添加标注
title('my plot') %图的标题
```

#### （4）保存图像到本地文件
```
print -dpng 'myPlot.png'
```

#### （5）关闭图像
```
close
```

#### （6）将图像绘制到两个窗口
```
figure(1) ;plot(t, y1);
figure(2) ;plot(t, y2);
```

#### （7）将两个图形绘制到窗口的不同区域
```
subplot(1,2,1); %将窗口1*2的格子，接下来使用第1个格子，绘制出坐标系
plot(t,y1);
subplot(1,2,2) %将窗口1*2的格子，接下来使用第2个格子，绘制出坐标系
plot(t,y2);
```

#### （8）确定图像的坐标系的范围
```
axis([0.5 1 -1 1]) %横坐标范围为0.5~1，纵坐标的范围为-1~1
```

#### （9）清除窗口的所有图像
```
clf
```

#### （10）使用色块可视化矩阵
```
A = magic(5) %创建幻方
imagesc(A) %使用色块绘制幻方

imagesc(A), colorbar, colormap gray %使用色块绘制矩阵A, 添加色标，将颜色映射到灰色
```

#### （11）一条命令多条语句
```
a=1, b=1, c=1 %可以使用逗号分隔，将显示输出
a=1; b=1; c=1; %使用分号分隔，不会显示输出
```


### 5、流程控制和函数
#### （0）基本结构
```
控制语句 控制条件,
	循环体;
end;
```

#### （1）`if elseif else`判断语句
> if 条件1,
> %语句;
> elseif 条件2,
> %语句;
> else
> %语句;
> end;

```
if v(1) ==1,
  disp('v(1)=1');
elseif v(1)==2,
  disp('v(1)==2');
else
  disp('other');
end;
```

#### （2）`for`循环
> for i=行向量,
> %循环体;
> end;

```
v = zeros(10,1)
for i=1:10,
	v(i) = 2^1;
end;
	```

#### （3）`while continue break` 循环
 > while 条件,
 > %循环体;
 > if 条件 %可选语句
 > break; %或者continue;
 > end;
 > end;


```
i=1;
while i<=5,
v(i) = 100;
i = i+1;
end;

i=1;
while true,
 v(i) = 100;
 i = i+1;
 if i==6
  break;
 end;
end;
```

#### （4）函数创建与使用
* 创建一个文件命名为`函数名.m`的函数文件
* 编写函数
* 切换到函数文件所在的目录，或者将函数文件所在路径加入到搜索路径
* 在命令行执行函数

**创建文件`squareAndCubeNumber.m`**
```
function [y1,y2]=squareAndCubeNumber(x) %函数声明
%在此写函数执行过程
y1 = x^2; %函数返回值，或者说函数体
y2 = x^3; %函数支持多个返回值
```

**cd 到函数所在目录**
或者
**将路径加入到搜索路径**
```
addpath('目录的路径')
```

**调用函数**
```
y1 = squareAndCubeNumber(2) %只接受第一个返回值
[y1,y2]=squareAndCubeNumber(2)
```

**例子**：计算线性回归中的代价函数的值
文件`costFunctionJ.m`
```
function J = costFunctionJ(X, y, theta) %函数定义，接收参数参见上面
m = size(X,1); %获取训练的组数，就是X的行数
predictions = X*theta; %每一组训练数据的带入假设函数后的值
sqrErrors = (predictions-y).^2; %算出误差

J = 1/(2*m) * sum(sqrErrors); %带入公式
```

执行
```
X = [1 1; 1 2; 1 3]
y = [1; 2; 3]
theta = [0; 1]
costFunctionJ(X,y,theta)
```


### 6、向量化
无论你是用Octave，还是别的语言，比如MATLAB，或者你正在用Python、NumPy或Java、C，C++。所有这些语言都具有，各种线性代数库，这些库文件都是内置的，容易阅读和获取。他们通常写得很好，已经经过高度优化，通常是数值计算方面的博士，或者专业人士开发的。而当你实现机器学习算法时，如果你能，好好利用这些，线性代数库或者说，数值线性代数库，并联合调用它们。而不是自己去做那些，函数库可以做的事情。如果是这样的话，那么，通常你会发现 首先，这样更有效，也就是说运行速度更快。

#### （1）例子1
对于假设函数\\(h\_\theta(x)=\sum\_{j=0}^n \theta\_jx\_j\\)

可以转化为\\(\theta^Tx\\)，
其中：
* \\(\theta\\)为元素为\\(\theta\_0\\)到\\(\theta\_n\\)的列向量
* \\(x\\)为元素为\\(x\_0\\)到\\(x\_n\\)的列向量
```
prediction = theta' * X
```


#### （2）例子2
对于梯度下降算法中的公式
重复直到收敛{
\\(\theta\_j := \theta\_j - \alpha\frac{1}{m}\sum\_{i=1}^m((h\_\theta(x^{(i)})-y^{(i)})x\_j^{(i)})\\)
(同时更新对于每一个j =0,...,n)
}

可以转化为
$$
\theta := \theta - \alpha\delta
$$
其中：
* \\(\theta\\) 表示 n+1 维度的列向量
* \\(\alpha\\) 表示一个标量
* \\(\delta\\) 表示一个n+1维度的列向量；推导、定义如下
推导

**第一步**
\\( \delta=\frac{1}{m}\sum\_{i=1}^m((h\_\theta(x^{(i)})-y^{(i)})x^{(i)}) \\) 

\\( \delta=\frac{1}{m} func(Errors, X) \\) 

其中
* Errors 为一个m维的列向量=\\(X \theta - y\\)；
* X即其他见[例子](#二、多特征线性回归)和[正规方程](#5、正规方程Normal Equation求解线性回归)
* func 是一个操作：Errors的每一元素（从1到m号）乘以X每一行（从1到m行）的每一个元素（从1到n+1列）得到一个矩阵，再转置，按照行求和，得到一个n+1维度的列向量

**编程实现**
```
    Errors = X*theta - y;
%    delta = (1/m)*(sum(Errors .* X)'); %此方法为以上分析得，标准方法如下
    delta = (1/m)*X'*Errors;
    theta = theta - alpha*delta;
```

## 四、分类问题
****************************
### 1、分类问题简介
#### （1）例子
* 垃圾邮件标记
* 在线交易是否是诈骗
* 肿瘤良性恶性判断

两个类别的分裂
\\(y \in \\{0,1\\}\\)
其中
1 叫做正类用+表述
0 叫做负类用-表述

#### （2）不能使用线性回归算法
**线性回归的算法**
* 首先拟合数据
* 找到h(x)=0.5的分界点

**缺陷**
* 对于不规整的数据会出现极大的误差
* ** 线性回归**h(x)会出现0~1之外的情况，但是**逻辑回归**h(x)的取值只会在0~1之间

### 2、逻辑回归模型
#### （1）假设函数
$$
h\_\theta(x) = g(\theta^Tx) \\\\
g(z)= \frac{1}{1+e^{-z}}
$$
其中
`g(z)`称之为逻辑函数或者sigmoid（S形）函数
化简得
$$
h\_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}
$$


#### （2）假设函数的含义
\\(h\_\theta(x)\\) 表示在 \\(x\\) 和 \\(\theta\\) 情况下输出1的概率
$$
\begin{align\*}& h\_\theta(x) = P(y=1 | x ; \theta) = 1 - P(y=0 | x ; \theta) \newline& P(y = 0 | x;\theta) + P(y = 1 | x ; \theta) = 1\end{align\*}
$$


### 3、决策边界
假设函数
$$
h\_\theta(x) = g(z) \\\\
g(z)= \frac{1}{1+e^{-z}} \\\\
z 为我们设定的决策边界方程
$$

为了得到我们的离散0或1分类，我们可以将假设函数的输出转换如下：
$$
\begin{align\*}& h\_\theta(x) \geq 0.5 \rightarrow y = 1 \newline& h\_\theta(x) < 0.5 \rightarrow y = 0 \newline\end{align\*}
$$
我们的逻辑函数`g`的行为方式是当其输入大于或等于零时，其输出大于或等于0.5：
$$
\begin{align\*}& g(z) \geq 0.5 \newline& when \; z \geq 0\end{align\*}
$$

如果我们设定的`z`方程为 \\(\theta^T X\\) 这就意味着
$$
\begin{align\*}& \theta^T x \geq 0 \Rightarrow y = 1 \newline& \theta^T x < 0 \Rightarrow y = 0 \newline\end{align\*}
$$

绘制出图形`z`方程就是决策边界

### 4、逻辑回归的代价函数
我们不能使用与线性回归相同的成本函数，因为逻辑函数会导致输出为波浪形，导致许多局部最优。换句话说，它不会是一个凸函数。

相反，我们用于逻辑回归的成本函数如下所示：
$$
\begin{align\*}& J(\theta) = \dfrac{1}{m} \sum\_{i=1}^m \mathrm{Cost}(h\_\theta(x^{(i)}),y^{(i)}) \newline & \mathrm{Cost}(h\_\theta(x),y) = -\log(h\_\theta(x)) \; & \text{if y = 1} \newline & \mathrm{Cost}(h\_\theta(x),y) = -\log(1-h\_\theta(x)) \; & \text{if y = 0}\end{align\*}
$$

### 5、实现逻辑回归的梯度下降算法
#### （1）化简代价函数
$$
\mathrm{Cost}(h\_\theta(x),y) = - y \; \log(h\_\theta(x)) - (1 - y) \log(1 - h\_\theta(x))
$$
此函数与上面的代价函数是等价的

**带入得**
$$
J(\theta) = - \frac{1}{m} \displaystyle \sum\_{i=1}^m [y^{(i)}\log (h\_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h\_\theta(x^{(i)}))]
$$

**向量化后为**（`g(x)`见[2、逻辑回归模型](#2、逻辑回归模型)）
$$
\begin{align\*} & h = g(X\theta)\newline & J(\theta) = \frac{1}{m} \cdot \left(-y^{T}\log(h)-(1-y)^{T}\log(1-h)\right) \end{align\*}
$$


#### （2）实现梯度下降算法
**梯度下降的一般形式**
$$
\begin{align\*}& Repeat \; \lbrace \newline & \; \theta\_j := \theta\_j - \alpha \dfrac{\partial}{\partial \theta\_j}J(\theta) \newline & \rbrace\end{align\*}
$$

**使用微积分带入化简**
$$
\begin{align\*} & Repeat \; \lbrace \newline & \; \theta\_j := \theta\_j - \frac{\alpha}{m} \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)}) x\_j^{(i)} \newline & \rbrace \end{align\*}
$$
请注意，该算法与我们在线性回归中使用的算法相同。我们还必须同时更新theta中的所有值。

**向量化后为**
$$
\theta := \theta - \frac{\alpha}{m} X^{T} (g(X \theta ) - \vec{y})
$$

### 6、高级优化
#### （1）其他可以求回归问题的算法
给出以下的实现
* 求出\\(J(\theta)\\)
* 求出\\(J(\theta)\\)的偏导数
$$
\begin{align\*} & J(\theta) \newline & \dfrac{\partial}{\partial \theta_j}J(\theta)\end{align\*}
$$

**优化算法**
* Gradient descent（梯度下降法）
* Conjugate gredient（共轭梯度法）
* BFGS（变尺度法）
* L-BFGS（限制变尺度法）

#### （2）优缺点
**优点**
* 不需要选择学习度\\(\alpha\\)
* 比梯度下降更快

**缺点**
* 太复杂

#### （3）在Octave中使用
**例子**
代价函数
\\(J(\theta)=(\theta\_1-5)^2 + (\theta\_2-5)^2\\) 
**实现**
我们可以编写一个返回这两个返回值的函数：
```
function [jVal, gradient] = costFuntion(theta)

	jVal = (theta(1)-5)^2 + (theta(2)-5)^2;
	gradient = zeros(2,1);
	gradient(1) = 2*(theta(1)-5);
	gradient(2) = 2*(theta(2)-5);
```
**调用**
```
%配置选项
%GradObj：设置梯度目标参数打开，你写的函数要提供一个梯度的值 
%MaxIter：设置最大的迭代次数
options = optimset('GradObj','on', 'MaxIter', '100');
initTheta = zersos(2,1); %初始化theta的值
%参数说明
%@costFunction函数指针
%initTheta初始化值
%options配置选项
%返回值说明
%optTheta：theta最优解
%functionVal：此时代价函数的解
%exitFlag：1代表结果已经收敛
[optTheta, functionVal, exitFlag] = fminunc(@costFunction,initTheta,options);
```
其中initTheta必须是2维以上的向量

### 7、多分类问题
现在，当我们有两个以上的类别时，我们将接近数据分类。而不是y = {0,1}，我们将扩展我们的定义，使得y = {0,1 ... n}。

由于y = {0,1 ... n}，我们将问题划分为n + 1（+1，因为索引从0开始）二分类问题;在每个类中，我们预测“y”是我们其中一个类的成员的概率。
$$
\begin{align\*}& y \in \lbrace0, 1 ... n\rbrace \newline& h\_\theta^{(0)}(x) = P(y = 0 | x ; \theta) \newline& h\_\theta^{(1)}(x) = P(y = 1 | x ; \theta) \newline& \cdots \newline& h\_\theta^{(n)}(x) = P(y = n | x ; \theta) \newline& \mathrm{prediction} = \max\_i( h\_\theta ^{(i)}(x) )\newline\end{align\*}
$$
**方法**
将多分类转化为2分类问题，
对于\\(h\_\theta^{(0)}\\)，将y=0映射为正类，其他映射为负类。运行二分类问题的算法得到的假设函数即为\\(h\_\theta^{(0)}\\)

对于新输入，\\(max(\max\_i( h\_\theta ^{(i)}(x) ))\\)时i的值就是该输入的分类结果


## 五、过度拟合的问题
*********************************************
### 1、拟合的一些概念
* 欠拟合、高偏差：模型不能很好的拟合数据
* 过度拟合、高方差：训练的假设函数参数过多，如果没有足够的训练数据，来约束参数，输出参数总能很好的拟合数据，代价函数非常接近于0，输出的模型不是泛化的，不能正确的对新数据产生正确的输出
* 恰好拟合：可以很好拟合数据，输出模型是泛化的可以很好的进行预测

### 2、过渡拟合解决方法
* 选择尽量少的特征变量数（舍弃了一些信息）
	* 人工选择特征
	* 模型选择算法
* 正规化
	* 保留所有特征，减少参数\\(\\theta\_j\\)大小
	* 当我们有很多有用的特征时，正则化效果很好。
	
### 3、正规化与代价函数
如果我们从假设函数中过度拟合，我们可以通过增加代价函数的项，来减少我们函数中的一些参数的权重

改变我们的代价函数为：
$$
min\_\theta\ \dfrac{1}{2m}\  \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)})^2 + \lambda\ \sum\_{j=1}^n \theta\_j^2
$$

其中λ是正则化参数，它决定了我们的θ参数的成本是多少。

使用上述成本函数与额外的求和，我们可以平滑我们的假设函数的输出，以减少过拟合。如果选择λ太大，可能会使功能平滑，导致欠拟合。如果λ= 0，或者太小，将可能发生过渡拟合

### 4、正规化线性回归
#### （1）梯度下降法
我们将修改梯度下降函数，将θ0与其余参数分开，因为我们不想惩罚θ0。
$$
\begin{align\*} & \text{Repeat}\ \lbrace \newline 
& \theta\_0 := \theta\_0 - \alpha\ \frac{1}{m}\ \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)})x\_0^{(i)} \newline 
& \theta\_j := \theta\_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)})x\_j^{(i)} \right) + \frac{\lambda}{m}\theta\_j \right] & \,\,\,\,\, j \in \lbrace 1,2...n\rbrace\newline & \rbrace 
\end{align\*}
$$

**变形后得**
$$
\theta\_j := \theta\_j(1 - \alpha\frac{\lambda}{m}) - \alpha\frac{1}{m}\sum\_{i=1}^m(h\_\theta(x^{(i)}) - y^{(i)})x\_j^{(i)}
$$
上述方程式的第一项，\\(1 - \alpha\frac{\lambda}{m}\\)将始终小于1。直观地，您可以看到它在每次更新时将\\(θ\_j\\)的值减少一些。
请注意，第二项现在与以前完全相同。


#### （2）正规方程法
$$
\begin{align\*}& \theta = \left( X^TX + \lambda \cdot L \right)^{-1} X^Ty \newline& \text{where}\ \ L = \begin{bmatrix} 0 & & & & \newline & 1 & & & \newline & & 1 & & \newline & & & \ddots & \newline & & & & 1 \newline\end{bmatrix}\end{align\*}
$$

正规化不仅可以避免过渡拟合，还可以避免出现不可逆的情况。

回想一下，如果`m<n`，那么\\(X^TX\\)将不可逆。但是现在加上了 `λ⋅L`，\\(X^TX + \lambda L\\)变得可逆。

### 5、正规化逻辑回归
我们可以使用与正规化线性回归相似的方法对逻辑回归正规化，来避免过渡拟合。
#### （1）代价函数
回想一下，我们的逻辑回归的成本函数是：
$$
J(\theta) = - \frac{1}{m} \sum\_{i=1}^m \large[ y^{(i)}\ \log (h\_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h\_\theta(x^{(i)})) \large]
$$

我们可以通过在末尾添加一项来正规化这个方程：
$$
J(\theta) = - \frac{1}{m} \sum\_{i=1}^m \large[ y^{(i)}\ \log (h\_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h\_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum\_{j=1}^n \theta\_j^2
$$
第二个求和项，\\(\sum\_{j=1}^n \theta\_j^2\\)明确的排除偏差项θ0。θ矢量从0到n（保持n + 1个值，θ0到θn），这个和通过从1到n跳过0来明确地跳过θ0。因此，当计算公式时，我们应该连续更新以下两个方程：

#### （2）梯度下降
和线性回归形式上相类似
$$
\begin{align\*} & \text{Repeat}\ \lbrace \newline 
& \theta\_0 := \theta\_0 - \alpha\ \frac{1}{m}\ \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)})x\_0^{(i)} \newline 
& \theta\_j := \theta\_j - \alpha\ \left[ \left( \frac{1}{m}\ \sum\_{i=1}^m (h\_\theta(x^{(i)}) - y^{(i)})x\_j^{(i)} \right) + \frac{\lambda}{m}\theta\_j \right] & \,\,\,\,\, j \in \lbrace 1,2...n\rbrace\newline & \rbrace 
\end{align\*}
$$




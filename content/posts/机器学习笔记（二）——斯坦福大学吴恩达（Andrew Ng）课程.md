---
title: 机器学习笔记（二）——斯坦福大学吴恩达（Andrew Ng）课程
date: 2017-05-18T22:39:04+08:00
draft: false
toc: false
comments: true
aliases:
  - /detail/78
  - /detail/78/
tags:
  - 机器学习
---

<script src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=default"></script>

## 目录
* [六、神经网络](#六、神经网络)
	* [1、神经网络的术语](#1、神经网络的术语)
	* [2、神经网络在分类问题中的应用](#2、神经网络在分类问题中的应用)
	* [3、神经网络编程准备](#3、神经网络编程准备)
* [七、应用机器学习的建议](#七、应用机器学习的建议)
	* [1、评估学习算法](#1、评估学习算法)
	* [2、算法的高偏差与高方差](#2、算法的高偏差与高方差)
	* [3、学习曲线](#3、学习曲线)  
	* [4、决定接下来如何做](#4、决定接下来如何做)
	* [5、样例——构建一个垃圾邮件分类器](#5、样例——构建一个垃圾邮件分类器)
	* [6、偏斜类（skewed classes）](#6、偏斜类（skewed classes）)
	* [7、使用更大的训练集](#7、使用更大的训练集)
* [八、支持向量机（SVM）](#八、支持向量机（SVM）)
	* [1、回顾逻辑回归](#1、回顾逻辑回归)
	* [2、支持向量机的代价函数](#2、支持向量机的代价函数)
	* [3、支持向量机的假设函数](#3、支持向量机的假设函数)
	* [4、核函数](#4、核函数)
	* [5、使用核函数的向量机](#5、使用核函数的向量机)
	* [6、支持向量机算法的一些参数](#6、支持向量机算法的一些参数)
	* [7、使用SVM](#7、使用SVM)
	* [8、何时选择SVM](#8、何时选择SVM)

## 六、神经网络
********************************
### 1、神经网络的术语
* \\(\theta\\) 参数矩阵称之为权重（weight）
* 神经元，一个计算单元
* 输入的偏度单元，指的是一默认输入  \\(x\_0=1\\)
* 神经网络，多个神经元输入输出相连构成的网络
* 神经网络输入层，输入了特征项 
* 神经网络输出层，输出结果
* 神经网络隐藏层，除了输入输出层
* 神经元的激励，神经元接收输入后获得的输出函数
* \\(a^{(j)}\_i\\) 表示第j层的第i个神经元的激励
* \\(\Theta^{(j)}\\) 表示从第j层到第j+1层控制函数映射的矩阵化权重
* 如果一个神经网络在\\(j\\)层的神经元数为\\(s\_j\\)，那么\\(\Theta^{(j)}\\)的维度为 \\(s\_{j+1} \times (s\_j +1) \\)
* \\(h\_\Theta(x)\\) 表示整个神经网络

$$
\begin{bmatrix}x\_0 \newline x\_1 \newline x\_2 \newline x\_3\end{bmatrix}\rightarrow\begin{bmatrix}a\_1^{(2)} \newline a\_2^{(2)} \newline a\_3^{(2)} \newline \end{bmatrix}\rightarrow h\_\theta(x)
$$

每个神经元激励如下
$$
\begin{align\*} a\_1^{(2)} = g(\Theta\_{10}^{(1)}x\_0 + \Theta\_{11}^{(1)}x\_1 + \Theta\_{12}^{(1)}x\_2 + \Theta\_{13}^{(1)}x\_3) \newline a\_2^{(2)} = g(\Theta\_{20}^{(1)}x\_0 + \Theta\_{21}^{(1)}x\_1 + \Theta\_{22}^{(1)}x\_2 + \Theta\_{23}^{(1)}x\_3) \newline a\_3^{(2)} = g(\Theta\_{30}^{(1)}x\_0 + \Theta\_{31}^{(1)}x\_1 + \Theta\_{32}^{(1)}x\_2 + \Theta\_{33}^{(1)}x\_3) \newline h\_\Theta(x) = a\_1^{(3)} = g(\Theta\_{10}^{(2)}a\_0^{(2)} + \Theta\_{11}^{(2)}a\_1^{(2)} + \Theta\_{12}^{(2)}a\_2^{(2)} + \Theta\_{13}^{(2)}a\_3^{(2)}) \newline \end{align\*}
$$


### 2、神经网络在分类问题中的应用
#### （1）一些定义
* L 表示神经网络的层数
* \\(s\_l\\) 表示在第l层中神经元节点的数目（不包括偏差单元）
* K 表示输出层神经元的数目
* 二元分类：\\(s\_L = 1\\)，输出是一个实数，K=1
* 多元分类：\\(s\_L = K\\)，输出是一个K维向量（K>=3）

#### （2）代价函数
逻辑回归的情况：
$$
J(\theta) = - \frac{1}{m} \sum\_{i=1}^m \large[ y^{(i)}\ \log (h\_\theta (x^{(i)})) + (1 - y^{(i)})\ \log (1 - h\_\theta(x^{(i)}))\large] + \frac{\lambda}{2m}\sum\_{j=1}^n \theta\_j^2
$$

神经网络的情况
$$
\begin{gather\*} J(\Theta) = - \frac{1}{m} \sum\_{i=1}^m \sum\_{k=1}^K \left[y^{(i)}\_k \log ((h\_\Theta (x^{(i)}))\_k) + (1 - y^{(i)}\_k)\log (1 - (h\_\Theta(x^{(i)}))\_k)\right] + \frac{\lambda}{2m}\sum\_{l=1}^{L-1} \sum\_{i=1}^{s\_l} \sum\_{j=1}^{s\_{l+1}} ( \Theta\_{j,i}^{(l)})^2\end{gather\*}
$$


#### （3）求J的偏导数——反向传播算法
得到了\\(J\\)，要求出\\(\min\_\Theta J(\Theta)\\)需要求出以下两个部分：
$$
\dfrac{\partial}{\partial \Theta\_{i,j}^{(l)}}J(\Theta)
$$
如此就可以使用梯度下降或者其他优化算法求出\\(Theta\\)

假设只有一组训练样本\\((x,y)\\)，四层神经网络（L=4）
**正向传播** 求出\\(h\_\Theta\\)
$$
\begin{align}
& a^{(1)} = x \\\\
& z^{(2)} = \Theta^{(1)} a^{(1)} \\\\
& a^{(2)} = g(z^{(2)}) \quad (加入 a\_0^{(2)}) \\\\
& z^{(3)} = \Theta^{(2)} a^{(2)} \\\\
& a^{(3)} = g(z^{(3)}) \quad (加入 a\_0^{(3)}) \\\\
& z^{(4)} = \Theta^{(3)} a^{(3)} \\\\
& a^{(4)} = h\_\Theta(x) = g(z^{(4)}) \\\\
\end{align}
$$

**反向传播** 求出 \\(\triangle\\)
定义：\\(\delta\_j^l\\) = 第l层第j个节点的误差
$$
\begin{align}
& \delta\_j^{(4)} = a\_j^{(4)} - y\_i =  (h\_\Theta(x))\_j - y\_i \\\\\
以下为向量化后 \\\\
& \delta^{(4)} = a^{(4)} - y  \\\\
& \delta^{(3)} = (\Theta^{(3)})^T \delta^{(4)} .\*  g^{'}(z{(3)}) \quad (其中 g^{'}(z{(3)})=a^{(3)} .\* (1-a^{(3)}) ) \\\\
& \delta^{(2)} = (\Theta^{(2)})^T \delta^{(3)} .\*  g^{'}(z{(2)}) \quad (其中 g^{'}(z{(2)})=a^{(2)} .\* (1-a^{(2)}) ) \\\\
& no \, \delta^{(1)} \\\\
\end{align}
$$

**结果**
$$
\dfrac{\partial}{\partial \Theta\_{i,j}^{(l)}}J(\Theta) = a\_j^{(l)} \delta\_i^{(l+1)} \quad 忽略了正规化
$$

**伪代码**
对于训练集\\( \\{ (x^{(1)}, y^{(1)}), ..., (x^{(1)}, y^{(1)}) \\} \\)
设置\\(\Delta\_{ij}^{(l)} = 0\\) 对于所有的\\(l,i,j\\)

For i=1 to m
设置 \\(a^{(1)} = x^{(i)} \\)
使用正向传播依次计算 \\(a^{(l)}\\)，其中 \\(l = 2,3,4,...,L \\)
使用\\(y^{(i)}\\) 计算\\(\delta^{(L)} = a^{(L)} - y^{(i)}\\)
使用反向传播依次计算\\( \delta^{(L-1)}, \delta^{(L-2)}, \delta^{(L-3)}, ..., \delta^{(2)} \\)
\\( \Delta\_{ij}^{(l)} := \Delta\_{ij}^{(l)} + a\_j^{(l)}\delta\_i^{(l+1)}  \\) 或者，向量化
\\( \Delta{(l)} := \Delta^{(l)} + \delta^{(l+1)} (a^{(l)})^T  \\)
End

\\( D\_{ij}^{(l)} = \frac{1}{m}\Delta\_{ij}^{(l)} + \lambda\Theta\_{ij}^{(l)}\quad if\,j \neq 0 \\)
\\( D\_{ij}^{(l)} = \frac{1}{m}\Delta\_{ij}^{(l)}\quad if\,j=0 \\)

那么：
\\( \dfrac{\partial}{\partial \Theta\_{i,j}^{(l)}}J(\Theta) = D\_{ij}^{(l)}  \\)



### 3、神经网络编程准备
#### （1）展开theta参数为一个向量并恢复
由于一些优化的逼近算法传递的是一个列向量，所有需要将列向量转换为一个个的theta

使用神经网络，我们正在使用矩阵集合：
$$
\begin{align\*} \Theta^{(1)}, \Theta^{(2)}, \Theta^{(3)}, \dots \newline D^{(1)}, D^{(2)}, D^{(3)}, \dots \end{align\*}
$$

```
thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]
deltaVector = [ D1(:); D2(:); D3(:) ]
```
如果Theta1的尺寸为10x11，则Theta2为10x11，Theta3为1x11，则可以从“展开”版本获取原始矩阵，如下所示：
```
Theta1 = reshape(thetaVector(1:110),10,11)
Theta2 = reshape(thetaVector(111:220),10,11)
Theta3 = reshape(thetaVector(221:231),1,11)
```

#### （2）使用导数定义检验反向传播正确性
根据导数定义可得：
$$
\dfrac{\partial}{\partial\Theta}J(\Theta) \approx \dfrac{J(\Theta + \epsilon) - J(\Theta - \epsilon)}{2\epsilon}
$$
偏导数
$$
\dfrac{\partial}{\partial\Theta_j}J(\Theta) \approx \dfrac{J(\Theta_1, \dots, \Theta_j + \epsilon, \dots, \Theta_n) - J(\Theta_1, \dots, \Theta_j - \epsilon, \dots, \Theta_n)}{2\epsilon}
$$

通常设置\\( \epsilon = 10^{-4} \\)

编码实现使用导数/偏导数定义计算
```
epsilon = 1e-4;
for i = 1:n,
  thetaPlus = theta;
  thetaPlus(i) += epsilon;
  thetaMinus = theta;
  thetaMinus(i) -= epsilon;
  gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*epsilon)
end;
```

然后检查 是否`gradApprox ≈ deltaVector`，若成立表名反向传播表现正常

总结
* 反向传播和导数定义都可以计算导数
* 反向传播可能出现问题，但是效率很高
* 导数定义绝对正确，但是效率很低，仅仅可以作为反向传播的验证




#### （3）随机初始化theta
将所有theta权重初始化为零不适用于神经网络。当我们反向传播时，所有节点将重复更新到相同的值。相反，我们可以使用以下方法随机初始化我们的Θ矩阵的权重：

初始化每一个 \\(\Theta^{(l)}\_{ij}\\)为一个在\\([-\epsilon,\epsilon]\\) 范围内的随机值，实现如下
如果 Theta1 是 10x11, Theta2 是 10x11 ， Theta3 是 1x11.
```
Theta1 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;
Theta2 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;
Theta3 = rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON;
```

`rand(x,y)`只是octave 中的一个函数，它将初始化0到1之间的随机实数的矩阵。
（注意：上面使用的epsilon与Gradient检查中的epsilon无关）

#### （4）一些总结
* 分析建立模型框架，有几层，每层几个节点等
* 实现神经网络的训练过程
	* 随机初始化权值
	* 执行向前传播算法
	* 计算\\(J(\Theta)\\)
	* 执行反向传播计算偏微分
	* 使用微分定义检验反向传播求出的正确性
	* 使用优化的最小化算法计算出最优解



## 七、应用机器学习的建议
********************************************
### 1、评估学习算法
当机器学习算法运行的不尽如人意时，如何优化？有如下选择
* 获取更多的训练样本
* 尝试使用更小的特征集
* 尝试增加特征
* 添加多项式项
* 增大正规化的\\(\lambda\\)
* 减小正规化的\\(\lambda\\)

最重要的是如何选择这些方法，不用改使用直觉，而要使用一些诊断法


#### （1）评价假设函数
将训练集分为两个部分（7:3），最好随机选择：
* 常用训练集（7）
* 测试集（3）

步骤
* 使用常用训练集来训练模型得到参数\\(\theta\\)和\\(J\_{train}(\theta)\\)
* 使用测试集计算误差\\(J\_{test}(\Theta)\\)

测试集误差：
* 线性回归：\\(J\_{test}(\Theta) = \dfrac{1}{2m\_{test}} \sum\_{i=1}^{m\_{test}}(h\_\Theta(x^{(i)}\_{test}) - y^{(i)}\_{test})^2\\)
* 逻辑回归

$$
err(h\_\Theta(x),y) = \begin{matrix} 1 & \mbox{if } h\_\Theta(x) \geq 0.5\ and\ y = 0\ or\ h\_\Theta(x) < 0.5\ and\ y = 1\newline 0 & \mbox otherwise \end{matrix}
$$

$$
\text{Test Error} = \dfrac{1}{m\_{test}} \sum^{m\_{test}}\_{i=1} err(h\_\Theta(x^{(i)}\_{test}), y^{(i)}\_{test})
$$




#### （2）模型选择和训练集/验证集/测试集
给出了具有不同多项式度的许多模型，我们可以使用系统的方法来识别“最佳”函数。为了选择您的假设模型，您可以测试不同多项式度的模型并查看误差结果。
将训练集分为三个部分（6:2:2），最好随机选择：
* 常用训练集（6）
* 交叉验证集（2）
* 测试集（2）

我们现在可以使用以下方法计算三个不同集合的三个单独的错误值：

* 使用每个多项式度的模型，使用训练集训练，并得到最优的时，Θ的值
* 使用交叉验证集找到具有最小误差的多项式度d。
* 使用测试集估计广义误差\\(J\_{test}(\Theta^{(d)})\\)，其中d表示上一步得到的误差最小的模型多项式的度

这样，多项式的度d，没有使用测试集进行训练选择，确保评估假设函数的科学性


### 2、算法的高偏差与高方差
**高偏差（欠拟合）bias-variance**
\\(J\_{train}(\Theta^{(d)})\\) 很大
\\(J\_{cv}(\Theta^{(d)}) \approx (J\_{train}(\Theta^{(d)}) \\)

**高方差（过拟合）variance**
\\(J\_{train}(\Theta^{(d)})\\) 很小
\\(J\_{cv}(\Theta^{(d)}) >> (J\_{train}(\Theta^{(d)}) \\)

#### （1）算法误差与假设函数多项式的度的关系

以 误差为纵坐标，横坐标为多项式的度 绘制出函数\\(J\_{train}(\Theta^{(d)})\\)与\\(J\_{cv}(\Theta^{(d)})\\)。**此时的代价函数没有加入正规化项**
\\(J\_{train}(\Theta^{(d)})\\)  单调递减
\\(J\_{cv}(\Theta^{(d)}) \\) 先减后曾


#### （2）算法误差与正规化参数\\(\lambda\\)的关系
以 误差为纵坐标，横坐标为正规化参数\\(\lambda\\) 绘制出函数\\(J\_{train}(\Theta^{(d)})\\)与\\(J\_{cv}(\Theta^{(d)})\\)。

\\(J\_{train}(\Theta^{(d)})\\)  单调递增
\\(J\_{cv}(\Theta^{(d)}) \\) 先减后曾

诊断法：
* 创建一个\\(\lambda \\)列表 (例如 λ∈{0,0.01,0.02,0.04,0.08,0.16,0.32,0.64,1.28,2.56,5.12,10.24});
* 创建一个具有不同度或参数的模型的集合
* 依次训练模型
* 使用上面训练出的模型，计算（λ = 0，也就是说纯粹看误差）误差\\(J\_{CV}(\Theta)\\)
* 选择在交叉验证集上产生误差最小的最佳组合
* 使用最佳的Θ 和 λ，计算出\\(J\_{test}(\Theta)\\)，观察是否能够很好的泛华的决问题


### 3、学习曲线
误差作为纵坐标，训练集样本数m作为纵坐标 绘制出函数\\(J\_{train}(\Theta^{(d)})\\)与\\(J\_{cv}(\Theta^{(d)})\\)。
在计算过程中，\\(J\_{train}(\Theta^{(d)})\\)的计算是对于部分训练集的，而\\(J\_{cv}(\Theta^{(d)})\\)的计算是对于所有交叉集的。

**高偏差（欠拟合）**
\\(J\_{cv}(\Theta^{(d)})\\) 单调递减，并趋近于平缓
\\(J\_{train}(\Theta^{(d)})\\) 单调递曾，并趋近于平缓

可知：在高偏差情况下，增加训练样本对训练无益，所以不必花时间收集数据

**高方差（过拟合）**
\\(J\_{cv}(\Theta^{(d)})\\) 一直很大，缓慢递减，并趋近于平缓
\\(J\_{train}(\Theta^{(d)})\\) 一直很小，缓慢递增，并趋近于平缓
以上两者相差很大

可知：在高偏差情况下，增加训练样本对训练有益。


### 4、决定接下来如何做
当机器学习算法运行的不尽如人意时，如何优化？有如下选择
* 获取更多的训练样本 ———— 高方差（过拟合）
* 尝试使用更小的特征集 ———— 高方差（过拟合）
* 尝试增加特征 ———— 高偏差（欠拟合）
* 添加多项式项 ———— 高偏差（欠拟合）
* 增大正规化的\\(\lambda\\) 高偏差（欠拟合）
* 减小正规化的\\(\lambda\\) 高方差（过拟合）

神经网络的规模与拟合度
* 小规模神经网络，易出现欠拟合，计算量小
* 大规模神经网络，易出现过拟合，计算量大

如何选择神经网络层数
* 将训练集分割成三部分测试那个层次效果最优（\\(J\_{cv}\\)）最优


### 5、样例——构建一个垃圾邮件分类器
#### （1）确定先做什么
给定一封电子邮件的数据集，我们可以为每个电子邮件构建一个向量。该向量中的每个条目表示一个单词，该向量中的每个条目表示一个单词。矢量通常包含10,000到50,000个条目，通过查找我们的数据集中最常用的单词来收集。如果在电子邮件中找到一个字，我们将分配其相应的条目1，否则如果没有找到该条目，该条目将为0。一旦我们准备好所有的x向量，我们就会训练我们的算法，最后我们可以用它来分类邮件是否是垃圾邮件。

那么，你如何花时间来提高这个分类器的准确性？

* 收集大量数据（例如“蜜罐”项目，但并不总是工作）
* 选择更加复杂的特征（例如：在垃圾邮件中使用电子邮件头数据）
* 开发预处理算法以不同的方式处理您的输入（识别垃圾邮件中的拼写错误）。




#### （2）误差分析
解决机器学习问题的推荐方法是：
* 从一个简单的算法开始，快速实现，并在交叉验证数据的早期进行测试。
* 绘制学习曲线，以决定是否有更多的数据，更多的功能等可能有帮助。
* 手动检查交叉验证集中的示例错误，并尝试发现大多数错误发生的趋势。

例如，假设我们有500封电子邮件，我们的算法将其中的100个错误分类。我们可以手动分析100封电子邮件，并根据他们的电子邮件类型进行分类。然后，我们可以尝试提出新的线索和功能，以帮助我们正确地分类这100封电子邮件。因此，如果大多数错误分类的电子邮件是尝试窃取密码的邮件，那么我们可以找到这些电子邮件特有的功能，并将其添加到我们的模型中。我们还可以看到，根据根的变化对每个单词进行分类会改变我们的错误率。

将错误结果作为单个数值非常重要。否则很难评估你的算法的性能。例如，如果我们使用词干，这是将不同形式的同一个单词（fail/failing/failed）视为一个单词（fail）的过程，并将错误率从5％降到3％，那么我们应该把它添加到我们的模型中。但是，如果我们尝试区分大写字母和小写字母，最终将错误率从3％提高到3.2％，那么我们应该避免使用这个特征。



### 6、偏斜类（skewed classes）
#### （1）定义
对于癌症分类器的例子，训练逻辑回归模型。y=1，代表得癌症；y=0代表没得癌症。
这时，你将发现在测试集上你将得到1%的误差。

但是我们发现测试集中仅有0.5%的人患癌症。

假设我们的模型是 y=0；也就是说，所有人都没患有癌症。这时你就仅有0.5%的误差了。比机器学习的结果还好？

> 正类比负类少的的多的情况称之为偏斜类

这时使用分类误差（分类精度）作为评估量度就会出现问题


#### （2）查准率（Precision）和召回率（Recall）

|预测值|真实值 1 |真实值 0 |
|:---|:--|:-|
|  1  | 真阳性（true positive）   | 假阳性（false positive） |
|  0  | 假阴性（false negative）   | 假阳性（true negative） |

**查准率（Precision）**
我们预测为真的数目中，有多少正确的
$$
\frac{ 真阳性（true positive） }{预测为1的（\\#predicted positive）} = \frac{ 真阳性（true positive） }{真阳性（true positive） + 假阳性（false positive）}
$$
对于癌症的问题代表 `1 - 误诊率`

**召回率（Recall）**
所有为真的数目中，有多少被预测为真
$$
\frac{ 真阳性（true positive） }{预测为1的（\\#actived positive）} = \frac{ 真阳性（true positive） }{真阳性（true positive） + 假阴性（false negative）}
$$
对于癌症的问题代表 `1 - 漏诊率`


#### （2）使用查准率和召回率评估偏斜类
对于\\(h\_\theta{(x)}\\)的划分为1和0的分界值默认为0.5

若分界值提高为0.9，将获得较高的查准率，较低的召回率。（对于例子，误诊率低，漏诊率高）
若分界值提高为0.1，将获得较低的查准率，较高的召回率。（对于例子，误诊率高，漏诊率低）

因此，查准率和召回率一般不会同时最优，两者相互排斥。

若我们折中查准率和召回率来评估算法那么
定义，查准率为`P`，召回率为`R`：
$$
F\_1 = 2\frac{PR}{P+R}
$$
选择\\(F\_1\\)大的模型





### 7、使用更大的训练集
在大数据时代，有一个说法，"取得成功的人不是拥有最好算法的人 而是拥有最多数据的人"。
那么这种说法，在什么时候是真，什么时候是假呢？ 

假设在我们的机器学习问题中，特征值 x 包含了足够的信息，这些信息可以帮助我们用来准确地预测y，则大量的数据集是有效的。

如何判断特征值 x 是否包含了足够的信息：
如果我们使用特征x，去请教这个领域的人类专家，一个人类专家能够，准确或自信地预测出 y 的值吗？特征值 x 是否包含了足够的信息。

如果，你有大量的数据，而且你训练了一种带有很多参数的学习算法。
若你的算法具有好的性能要包含两点：
* 首先，一个人类专家看到了特征值 x，能很有信心的预测出 y值吗？ 因为这可以证明y可以根据特征值x被准确地预测出来
* 其次，我们实际上能得到一组庞大的训练集并且在这个训练集中训练一个有很多参数的学习算法吗






## 八、支持向量机（SVM）
***********************************
### 1、回顾逻辑回归
#### （1）假设函数
$$
\begin{align}
& h\_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} \\\\
& h\_\theta(x) = g(\theta^Tx) \\\\
& g(z) = \frac{1}{1+e^{z}} 
\end{align}
$$

* 如果 \\(y=1\\)，想要 \\(\theta^Tx >> 0\\)，则\\(h\_\theta(x) \approx 1\\)
* 如果 \\(y=1\\)，想要 \\(\theta^Tx << 0\\)，则\\(h\_\theta(x) \approx 0\\)

#### （2）代价函数
$$
J(\theta) = \frac{1}{m} \displaystyle \sum\_{i=1}^m [y^{(i)} (- \log h\_\theta (x^{(i)}))) + (1 - y^{(i)}) (- \log (1 - h\_\theta(x^{(i)})))] + \frac{\lambda}{2m} \sum\_{j=1}^n \theta\_j^2
$$


### 2、支持向量机的代价函数
$$
J(\theta) =  \displaystyle C \sum\_{i=1}^m [y^{(i)} cost\_1( \theta^T x^{(i)} ) + (1 - y^{(i)})  cost\_0( \theta^T x^{(i)} ) ]+ \frac{1}{2} \sum\_{j=1}^n \theta\_j^2
$$

与逻辑回归的对比
* 用\\(C\\)代替\\(\lambda\\)，等价关系为：\\(C = \frac{1}{\lambda}\\)
* 去掉了常数\\(\frac{1}{m}\\)
* 使用cost函数代替log，cost是log的线性拟合形式函数

### 3、支持向量机的假设函数
$$
h\_\theta(x) = \begin{matrix} 1 & \mbox{if } \theta^Tx \geq 0\ \newline 0 & \mbox otherwise \end{matrix}
$$


### 4、核函数
#### （1）逻辑回归中非线性决策边界的假设函数
对于有两个特征变量
要预测\\(y=1\\)，则假设函数为：
$$
h\_\theta(x) = \theta\_0 + \theta\_1x\_1 + \theta\_2x\_2 + \theta\_3x\_1x\_2 + \theta\_4x\_1^2 + \theta\_5x\_2^2 + ... 
$$

那么现在使用\\(f\_n\\)代替以上的x相关项
$$
h\_\theta(x) = \theta\_0 + \theta\_1f\_1 + \theta\_2f\_2 + \theta\_3f\_3 + \theta\_4f\_4 + \theta\_5f\_5 + ...
$$

现在定义\\(f\_i\\)
$$
f\_i = similarity(x,l^{(i)}) = exp(- \frac{||x - l^{(i)}||}{2\sigma ^2})
$$
其中：
* \\(exp(- \frac{||x - l^{(i)}||}{2\sigma ^2})\\) 就成为一种核函数，这个形式叫做高斯核函数
* \\(l^{(i)}\\)称之为参考点
* \\(||x - l^{(i)}||\\)表示向量\\(x\\)与\\(l^{(i)}\\)所表示点的直线距离
* \\(\sigma^2\\)描述的是相似函数的尺度

含义
* 本函数描述的是当前点到参考点\\(l^{(i)}\\)的距离的大小
* 当\\(x\\)与\\(l^{(i)}\\)接近于重合时，\\(f\_i\\) 趋向于1
* 当\\(x\\)与\\(l^{(i)}\\)趋向于无限远时，\\(f\_i\\) 趋向于0

#### （2）选择参考点\\(l^{(i)}\\)
一般情况下参考点的选择为所有的**训练样本**中\\(x^{(i)}\\)所表示的点。
即
$$
f\_i = similarity(x,x^{(i)}) 
$$


### 5、使用核函数的向量机
#### （1）假设函数
$$
h\_\theta(x) = \begin{matrix} 1 & \mbox{if } \theta^Tf \geq 0\ \newline 0 & \mbox otherwise \end{matrix}
$$
其中 f 是 m+1 维的向量，其中\\(f^{(0)}=1\\)

#### （2）代价函数
$$
J(\theta) =  \displaystyle C \sum\_{i=1}^m [y^{(i)} cost\_1( \theta^T f^{(i)} ) + (1 - y^{(i)})  cost\_0( \theta^T f^{(i)} ) ]+ \frac{1}{2} \sum\_{j=1}^n \theta\_j^2
$$
其中 n = m


### 6、支持向量机算法的一些参数
#### （1）C（\\(\frac{1}{\lambda}\\)）
* 过大，低偏差(bias)，高方差(variance)，过拟合，相当于\\(\lambda\\)很小
* 过小，高偏差(bias)，低方差(variance)，欠拟合，相当于\\(\lambda\\)很大

#### （2）\\(\sigma^2\\)
* 过大，\\(f\_{i}\\)过于平滑
	* 高偏差(bias)，低方差(variance)，欠拟合
* 过小，\\(f\_{i}\\)过于陡峭，（每个点仅仅受相近的点影响）
	* 低偏差(bias)，高方差(variance)，过拟合
 
 
### 7、使用SVM
选择合适的支持SVM的软件包（liblinear, libsvm）

#### （1）需要指定的参数
* C，防止欠拟合过拟合
* 选择一个核函数（相似函数）

#### （2）核函数
* 线性核函数（不使用核函数），参见 [支持向量机的代价函数](#2、支持向量机的代价函数) 和 [支持向量机的假设函数](#3、支持向量机的假设函数)
* 高斯核函数见上，需要指定\\(\sigma^2\\)
* 多项式核函数（Polynomial kernel），\\(k(x,l) = (x^T l + conctant)^{degree}\\)，需要指定常数和指数
* 字符串核函数(String kernel)
* chi-square kernel
* histogram intersection kernel

#### （3）多分类问题
* 使用库函数内置的多分类器
* 构造k个svm二元分类器
	
 
### 8、何时选择SVM
* 如果n相对于m很大（例如：n>=m，n=1000，m=10~1000）
	* 使用逻辑回归或者没有核函数的SVM
* 如果n很小，m适中（例如：n=1~1000，m=10~10000）
	* 使用核函数为高斯核函数的SVM
* 如果n很小，m很大（例如：n=1~1000，m=50000+）
	* 寻找更多的特征，使用逻辑回归或者没有核函数的SVM

神经网络，更加通用，但是效率可能会很低

